from requests import get   #импортируем метод get для запросов
from pymystem3 import Mystem #морфологический анализатор для русского языка
from nltk.tokenize import PunktSentenceTokenizer as PST  #Класс для выделения предложений
from nltk.tokenize import WordPunctTokenizer as WPT      #класс для разделения слов в предложении
from pymystem3 import Mystem #морфологический анализатор для русского языка
from multiprocessing import Process, freeze_support, Queue
from time import time, sleep

st = PST() #обозначение переменных как класс
wt = WPT() #обозначение переменных как класс


Names1 = {} #создаем словарь для имен из первого текста
Names2 = {} #создаем словарь для имен из второго текста
my_file1 = open("some1.txt", "r", encoding='utf-8') #открыть файл с именем some1.txt с кодировкой utf-8 на чтение
my_file2 = open("some2.txt", "r", encoding='utf-8') #открыть файл с именем some2.txt с кодировкой utf-8 на чтение
text1 = my_file1.read() #в переменную text1 запоминаем все данные из файла some1.txt
text2 = my_file2.read() #в переменную text2 запоминаем все данные из файла some2.txt

text1_=st.sentences_from_text(text1)
lenS1=len(text1_)
text2_=st.sentences_from_text(text2)
lenS2=len(text2_)

def paral1(q1,q21): # определяем функцию с двумя аргументами - очередями
    _Kx = q21.get() # вытаскиваем список первого и последнего предложения, используемые для данного процесса, из q21
    for k in _Kx:
        xNames = text1_[k]
        for word in wt.tokenize(sentence):	#бежим по словам в выделенном тексте
            m = Mystem()
            analize = m.analyze(word) #Морфологический анализ слова
            print(m.analyze(word))
            for i in analize: #углубляемся в полученный словарь
                for j in i: 
                    for k in i[j]:
                        for m in k:
                            if "gr" in k:
                                for o in k[m]:
                                    if "муж" and "имя" in k[m]: #Проверяем есть ли параметры муж и имя
                                        if Names1.get(word) is None: #Если в словаре имен нет такого имени
                                            Names1.update({word: 1}) #добавляем его
                                        else:
                                            Names1[word] +=1 #Иначе инкрементируем индекс
                                        break #выходим из цикла разбора анализа
    q1.put(Names1) # кладем в очередь q1 получившийся словарь
def paral1(q2,q22): # определяем функцию с двумя аргументами - очередями
    _Kx = q22.get() # вытаскиваем список первого и последнего предложения, используемые для данного процесса, из q22
    for k in _Kx:
        xNames = text2_[k]
        for word in wt.tokenize(sentence):	#бежим по словам в выделенном тексте
            m = Mystem()
            analize = m.analyze(word) #Морфологический анализ слова
            print(m.analyze(word))
            for i in analize: #углубляемся в полученный словарь
                for j in i: 
                    for k in i[j]:
                        for m in k:
                            if "gr" in k:
                                for o in k[m]:
                                    if "муж" and "имя" in k[m]: #Проверяем есть ли параметры муж и имя
                                        if Names2.get(word) is None: #Если в словаре имен нет такого имени
                                            Names2.update({word: 1}) #добавляем его
                                        else:
                                            Names2[word] +=1 #Иначе инкрементируем индекс
                                        break #выходим из цикла разбора анализа
    q2.put(Names2) # кладем в очередь q2 получившийся словарь

N = 2 # задаем количество процессов
d = int(lenS1/N)
lenS21 = d*N # создаем переменную что бы определить количество предложений, невошедших в распораллеливаемые процессы
n,m = 0,d
if lenS21!=lenS1: # если все предложения не равны с lenS21
	m+=1 # увеличиваем конечную границу для процесса
	lenS21+=1 # увеличиваем переменную lenS21
t11 = [] # создаем пустой список t1
t21 = [] # создаем пустой список t2
for i in range(N): # бежим по всем процессам
	h1 = Queue() # создаем переменную h типа очередь
	h21 = Queue() # создаем переменную h типа очередь
	test1=range(n,m)
	h21.put(test1) # кладем в очередь h21 список test
	t1+=[h1] # кладем в 1 список очередь h1
	t21+=[h21] # кладем в 2 список очередь h2
	if lenS21!=lenS1: # если все предложения не равны с lenS21
		n=m # присваиваем начальной границе конечную
		m+=d+1 # увеличиваем конечную границу на d+1
		lenS21+=1 # увеличиваем количество используемых предложений
	else: # в противном случае
		n=m # присваиваем начальной границе конечную
		m+=d # увеличиваем конечную границу на d
		d = int(lenS1/N)
lenS22 = d1*N # создаем переменную что бы определить количество предложений, невошедших в распораллеливаемые процессы
n1,m1 = 0,d1
if lenS22!=lenS1: # если все предложения не равны с lenS21
	m1+=1 # увеличиваем конечную границу для процесса
	lenS22+=1 # увеличиваем переменную lenS21
t12 = [] # создаем пустой список t1
t22 = [] # создаем пустой список t2
for i in range(N): # бежим по всем процессам
	h12 = Queue() # создаем переменную h типа очередь
	h22 = Queue() # создаем переменную h типа очередь
	test1=range(n1,m1)
	h22.put(test1) # кладем в очередь h21 список test
	t12+=[h1] # кладем в 1 список очередь h1
	t22+=[h21] # кладем в 2 список очередь h2
	if lenS21!=lenS1: # если все предложения не равны с lenS21
		n1=m1 # присваиваем начальной границе конечную
		m1+=d1+1 # увеличиваем конечную границу на d+1
		lenS22+=1 # увеличиваем количество используемых предложений
	else: # в противном случае
		n1=m1 # присваиваем начальной границе конечную
		m1+=d1 # увеличиваем конечную границу на d
G = [] # пустой список
if __name__ == '__main__': # используем это условие для работы с параллельными процессами на винде
	freeze_support() # проверка того, должен ли исполняемый процесс запускать код, полученный по каналу, или нет.
	for f in range(2):
		g=Process(target=paral1, args= (t11[f],t21[f])) # создаем процесс с целью функцией sentence_paral и аргументами - очередями
		g=Process(target=paral2, args= (t12[f],t22[f])) # создаем процесс с целью функцией sentence_paral и аргументами - очередями
		g.start() # старт процесса
		G+=[g] # процессы в список
	for pe in G: # запускаем все процессы
		pe.join() # вызываем метод join
print(Names1)
print(Names2)
